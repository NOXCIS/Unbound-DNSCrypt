
services:

  server:
    image: localhost:5000/sut
    build:
      context: .
      dockerfile: Dockerfile
    volumes:
      - ./dnscrypt-proxy.toml:/config/dnscrypt-proxy.toml:ro
      - ./rootfs_overlay/etc/unbound/unbound.conf:/etc/unbound/unbound.conf:ro
    cap_add:
      - NET_BIND_SERVICE
      - NET_ADMIN
    # Note: sysctls may not work in Docker Desktop on macOS
    # On Linux hosts, you can add sysctls to allow larger buffers
    healthcheck:
      test: ["CMD", "/usr/local/bin/healthcheck"]
      interval: 30s
      timeout: 3s
      retries: 3
      start_period: 10s

  sut:
    # image: alpine:3.21@sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c
    image: alpine:3.22@sha256:4b7ce07002c69e8f3d704a9c5d6fd3053be500b7f1c69fc0d80990c2ad8dd412
    depends_on:
      - server
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    working_dir: /test
    entrypoint:
      - /bin/sh
      - -c
    command:
      - |
        set -ex
        apk add --no-cache bind-tools docker-cli docker-cli-compose

        # Find the server container by name pattern (should be something like unbound-dnscrypt-server-1)
        server_id="$$(docker ps --format '{{.ID}}\t{{.Names}}' | grep -E '(server|unbound-dnscrypt)' | grep -v sut | head -1 | awk '{print $$1}')"
        
        if [ -z "$${server_id}" ]; then
          echo "ERROR: Could not find server container"
          exit 1
        fi
        
        echo "Found server container: $${server_id}"

        docker exec $${server_id} /usr/local/bin/dnscrypt-proxy -version
        docker exec $${server_id} /usr/sbin/unbound -V
        docker exec $${server_id} /usr/sbin/unbound-checkconf /etc/unbound/unbound.conf

        sleep 10

        # Test dnscrypt-proxy on port 5053
        docker exec $${server_id} /usr/local/bin/dnsprobe -timeout=10s dnssec.works 127.0.0.1:5053
        ! docker exec $${server_id} /usr/local/bin/dnsprobe foo.local 127.0.0.1:5053
        ! docker exec $${server_id} /usr/local/bin/dnsprobe bar.local 127.0.0.1:5053

        # Test unbound on port 53
        dig @server -p 53 dnssec.works +dnssec +multi | tee /dev/stderr | grep -wq NOERROR
        ! dig @server -p 53 foo.local +dnssec +multi | tee /dev/stderr | grep -wq NOERROR
        ! dig @server -p 53 bar.local +dnssec +multi | tee /dev/stderr | grep -wq NOERROR

        # Test sigok with longer timeout - this domain can take longer to resolve
        dig @server -p 53 +timeout=15 sigok.verteiltesysteme.net +dnssec +multi | tee /dev/stderr | grep -wq NOERROR
        ! dig @server -p 53 +timeout=15 sigfail.verteiltesysteme.net +dnssec +multi | tee /dev/stderr | grep -wq NOERROR

        # Test that unbound forwards to dnscrypt-proxy
        # Query through unbound (port 53) should work the same as dnscrypt-proxy (port 5053)
        docker exec $${server_id} /usr/local/bin/dnsprobe -timeout=10s google.com 127.0.0.1:53
        docker exec $${server_id} /usr/local/bin/dnsprobe -timeout=10s cloudflare.com 127.0.0.1:53

        # # fail0[1-4].dnssec.works wasn't failing as expected
        # dig @server -p 5053 dnssec.works +dnssec +multi | tee /dev/stderr | grep -wq NOERROR
        # ! dig @server -p 5053 fail01.dnssec.works +dnssec +multi | tee /dev/stderr | grep -wq NOERROR
        # ! dig @server -p 5053 fail02.dnssec.works +dnssec +multi | tee /dev/stderr | grep -wq NOERROR
        # ! dig @server -p 5053 fail03.dnssec.works +dnssec +multi | tee /dev/stderr | grep -wq NOERROR
        # ! dig @server -p 5053 fail04.dnssec.works +dnssec +multi | tee /dev/stderr | grep -wq NOERROR

        # Also test dnscrypt-proxy directly for backward compatibility
        dig @server -p 5053 +timeout=15 sigok.verteiltesysteme.net +dnssec +multi | tee /dev/stderr | grep -wq NOERROR
        ! dig @server -p 5053 +timeout=15 sigfail.verteiltesysteme.net +dnssec +multi | tee /dev/stderr | grep -wq NOERROR